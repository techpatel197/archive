# ASP.NET Core CI Pipeline for .NET 8
# This pipeline is tailored for the dataarchaive project.

trigger:
- main

pool:
  vmImage: 'ubuntu-latest'

variables:
  buildConfiguration: 'Release'
  # The solution file path relative to the repository root.
  solution: 'dataarchaive.sln'

stages:
- stage: CI
  displayName: Continuous Integration
  jobs:
  - job: BuildAndTest
    displayName: Build, Test, and Analyze
    steps:
    - checkout: self
      fetchDepth: 0 # Fetches all history for release notes generation

    # Use the .NET 8.0 SDK as required by the project file.
    - task: UseDotNet@2
      displayName: 'Install .NET 8.0 SDK'
      inputs:
        packageType: 'sdk'
        version: '8.x'

    - task: DotNetCoreCLI@2
      displayName: '1. Restore Dependencies'
      inputs:
        command: 'restore'
        projects: '$(solution)' # Restore all projects in the solution

    - task: DotNetCoreCLI@2
      displayName: '2. Build Solution'
      inputs:
        command: 'buildm'
        projects: '$(solution)'
        arguments: '--configuration $(buildConfiguration) --no-restore'

    - task: DotNetCoreCLI@2
      displayName: '3. Run Tests'
      inputs:
        command: 'test'
        projects: '$(solution)' # Run all test projects in the solution
        arguments: '--configuration $(buildConfiguration) --no-build --no-restore'
      
    # =====================================================================
    # AI-POWERED ANALYSIS STEPS
    # =====================================================================
    - script: |
        echo "--- AI-Powered Code Review ---"
        echo "Running: gemini review --prompt 'Review this C# code for clarity, best practices, and potential bugs' $(git diff --name-only HEAD~1 HEAD)"
        # Placeholder for actual Gemini CLI command:
        # git diff --name-only HEAD~1 HEAD | xargs -I {} gemini review --prompt "Review C# code for clarity and bugs" {} > ai_review.txt
      displayName: '4. AI-Powered Code Review'
      condition: succeeded()

    - script: |
        echo "--- AI-Powered Security Scan ---"
        echo "Running: gemini scan --prompt 'Scan for common security vulnerabilities in C# like injection or misconfigurations' dataarchaive/"
        # Placeholder for actual Gemini CLI command:
        # gemini scan --prompt "Scan for common security vulnerabilities in C#" dataarchaive/ > security_scan_report.txt
      displayName: '5. AI-Powered Security Scan'
      condition: succeeded()

    - script: |
        echo "--- Generating Release Notes ---"
        git log --pretty=oneline -n 20 > recent_commits.txt
        echo "Running: gemini summarize --prompt 'Create user-facing release notes from these commits' recent_commits.txt"
        # Placeholder for actual Gemini CLI command:
        # gemini summarize --prompt "Create user-facing release notes from these commits" recent_commits.txt > $(Build.ArtifactStagingDirectory)/release_notes.md
        echo "New feature added for data archival. Bug fixes for reporting module." > $(Build.ArtifactStagingDirectory)/release_notes.md
      displayName: '6. Generate AI Release Notes'
      condition: succeeded()

    - task: PublishPipelineArtifact@1
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)'
        artifact: 'ReleaseDocumentation'
        publishLocation: 'pipeline'
      displayName: '7. Publish Release Notes Artifact'
      condition: succeeded()

    - script: |
        echo "--- A build step failed. Analyzing logs to find the root cause. ---"
        echo "Running: gemini summarize --prompt 'This build failed. What was the root cause based on the logs?'"
        # In a real pipeline, you would capture logs from previous steps to a file and pass it to Gemini.
      displayName: '8. Analyze Failure with AI'
      condition: failed()
